---
tags:
  - "#domain/programming"
  - "#type/knowledge"
  - "#level/intermediate"
  - "#lang/c"
status: 完善中
complexity: 中级
notetype: 学习笔记
resource: C语言程序设计
related:
  - "[[00_C_MOC]]"
  - "[[C语言基础 - 数据类型与变量]]"
  - "[[C语言基础 - 数组]]"
created: 2025-11-18 21:46:54
modified: 2025-11-18 21:46:54
---
# C语言进阶 - 指针详解

> [!abstract] 摘要
> 本笔记详细介绍C语言中的指针概念、定义、使用方法,包括指针数组、数组指针、函数指针和动态内存分配等高级主题。

## 🎯 Target
- [ ] 理解指针的本质和作用
- [ ] 掌握指针的定义和赋值方法
- [ ] 区分指针数组和数组指针
- [ ] 熟练使用函数指针
- [ ] 掌握malloc动态内存分配
- [ ] 避免内存泄漏

## 📝 Core

### 指针基础

#### 什么是指针?
- **地址**: `scanf("%d", &xxx)`中的`&`就是取地址运算符
- **指针**: 可以理解为地址,是存放地址的变量

#### 变量的两种访问方式
1. **直接访问**: 通过变量名
2. **间接访问**: 通过地址

```c
int a = 10;
printf("%d\n", a);         // 通过变量名访问: 10
printf("%p\n", &a);        // 查看地址
printf("%d\n", *(&a));     // 通过地址访问: 10
```

> [!tip] *运算符
> `*`是一个运算符,与`+`、`-`类似,其功能是取出内存地址中数据的值(取内容)。

#### 变量类型对比
```c
int a;              // 整型变量,存放整数
char c = 'c';       // 字符变量,存放字符
int array[];        // 数组,存放一串数据
int *p;             // 指针,存放地址
```

所有这些都是变量,只是变量的类型不同。

### 指针定义和使用

#### 定义指针
```c
int *p;     // 方式1(推荐)
int* p;     // 方式2(同样正确)
```

#### 指针赋值
```c
int a = 10;
int *p;
p = &a;     // 将a的地址赋给指针p
```

#### 使用指针访问变量
```c
int a = 10;
int *p = &a;

printf("a = %d\n", a);      // 直接访问: 10
printf("*p = %d\n", *p);    // 通过指针访问: 10

*p = 20;  // 通过指针修改a的值
printf("a = %d\n", a);      // 输出: 20
```

### 数组与指针

#### 数组名就是地址
```c
int arr[5] = {1, 2, 3, 4, 5};
printf("数组地址: %p\n", arr);      // 数组首地址
printf("首元素地址: %p\n", &arr[0]); // 等价于arr

// 数组名 = 数组的首地址 = 第一个元素的地址
```

> [!important] 重要概念
> 数组名本身就是一个地址,取数组地址的时候可以不加`&`。

#### 指针访问数组
```c
int arr[5] = {1, 2, 3, 4, 5};
int *p = arr;  // 或 int *p = &arr[0];

for (int i = 0; i < 5; i++) {
    printf("%d ", *(p + i));  // 通过指针访问数组元素
    // 或者 printf("%d ", p[i]);
}
```

### 指针数组 vs 数组指针

#### 指针数组(Array of Pointers)
指针数组是一个数组,数组的每个元素都是指针。

**定义方式:**
```c
int *p[5];  // 定义一个包含5个int*指针的数组
```

**示例:**
```c
int a = 10, b = 20, c = 30;
int *p[3];  // 指针数组,包含3个指针

p[0] = &a;
p[1] = &b;
p[2] = &c;

for (int i = 0; i < 3; i++) {
    printf("*p[%d] = %d\n", i, *p[i]);
}
```

#### 数组指针(Pointer to Array)
数组指针是一个指针,指向整个数组。

**定义方式:**
```c
int (*p)[5];  // 定义一个指向包含5个int元素的数组的指针
```

**示例:**
```c
int arr[5] = {1, 2, 3, 4, 5};
int (*p)[5] = &arr;  // p指向整个数组

// 访问元素
for (int i = 0; i < 5; i++) {
    printf("%d ", (*p)[i]);
}
```

> [!warning] 区别
> - `int *p[5]`: 指针数组,`[]`优先级高,先是数组
> - `int (*p)[5]`: 数组指针,`()`优先级高,先是指针

### 函数指针

#### 概念
函数指针是指向函数的指针,可以通过指针调用函数。

#### 定义方式
```c
void (*p)();                    // 指向无参数无返回值的函数
int (*p)(int, int);             // 指向两个int参数,返回int的函数
char* (*p)(char *pname);        // 指向char*参数,返回char*的函数
```

**说明:**
- `*`表示指针
- `()`表示是函数
- 函数指针是专用的,格式要求很强(参数类型、个数、返回值必须匹配)

#### 函数指针赋值
```c
int add(int a, int b) {
    return a + b;
}

int (*p)(int, int);  // 声明函数指针
p = add;             // 赋值:函数名就是地址,跟数组一样
```

#### 通过函数指针调用函数
有两种调用方式:

```c
// 方式1: 直接通过指针名+() (较常用)
int result = p(3, 5);

// 方式2: 取内容的方式 (*指针名)+()
int result = (*p)(3, 5);

printf("Result: %d\n", result);  // 输出: 8
```

#### 函数指针的实际应用
```c
int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }
int mul(int a, int b) { return a * b; }

// 函数指针数组
int (*operations[3])(int, int) = {add, sub, mul};

int a = 10, b = 5;
printf("Add: %d\n", operations[0](a, b));  // 15
printf("Sub: %d\n", operations[1](a, b));  // 5
printf("Mul: %d\n", operations[2](a, b));  // 50
```

### 动态内存分配 (malloc)

#### malloc函数
`malloc`用于动态分配内存,返回`void*`类型指针。

**定义方式:**
```c
int *p = (int*)malloc(n * sizeof(int));  // 分配n个int大小的空间
char *pstr = (char*)malloc(128);         // 分配128字节
```

**说明:**
- `malloc`指定开辟空间的大小(字节数)
- 返回值是`void*`无类型指针,需要强制转换成目标类型
- 用这种方式可以自选数组的大小

#### 检查malloc是否成功
使用`malloc`时要检查是否开辟成功:

```c
int *p = (int*)malloc(100 * sizeof(int));

if (p == NULL) {
    printf("Memory allocation failed!\n");
    exit(-1);
}

// 使用p...

free(p);  // 释放内存
p = NULL; // 避免野指针
```

> [!warning] 必须检查
> 总是检查`malloc`返回值是否为`NULL`,避免空指针访问导致程序崩溃。

#### free释放内存
使用`malloc`分配的内存必须手动释放:

```c
int *p = (int*)malloc(100 * sizeof(int));

// 使用内存...

free(p);      // 释放内存
p = NULL;     // 避免野指针
```

### 内存泄漏

#### 什么是内存泄漏?
**症状**: 程序刚运行时很顺畅,但运行一段时间后,程序崩溃。

**原因**:
- `malloc`申请(开辟)的空间,程序不会主动释放
- Linux中程序结束后,系统会直接回收这个空间
- 但程序运行期间未释放会导致内存不断增加

#### 避免内存泄漏的方法
1. **检查循环中是否一直申请malloc**
```c
// 错误示例:内存泄漏!
for (int i = 0; i < 1000; i++) {
    int *p = (int*)malloc(100 * sizeof(int));
    // 没有free!
}

// 正确示例
int *p = (int*)malloc(100 * sizeof(int));
for (int i = 0; i < 1000; i++) {
    // 使用p...
}
free(p);  // 循环结束后释放
```

2. **及时合理释放内存**
```c
int *p = (int*)malloc(100 * sizeof(int));
// 使用内存...
free(p);
p = NULL;  // 避免野指针
```

### 指针强制转换

指针可以强制把想要的数据存储到指定地址,但地址需要转换:

```c
int *p1 = (int*)0x0060ff00;  // 将地址0x0060ff00强制转换为int*类型
```

> [!warning] 危险操作
> 直接操作特定地址是危险的,通常只在嵌入式编程或系统编程中需要访问硬件寄存器时使用。

### 指针定义总结

```c
int a;              // 定义整型变量
int *p;             // 定义p为指向整型数据的指针变量
int a[5];           // 定义整型数组a,有5个元素
int *p[4];          // 定义指针数组p,由4个指向整型数据的指针元素组成
int (*p)[4];        // p为指向包含4个元素的一维数组的指针变量
int f();            // f为返回整型函数值的函数
int *p();           // p为返回一个指针的函数,该指针指向整型数据
int (*p)();         // p为指向函数的指针,该函数返回一个整数值
int **p;            // p是一个指针变量,它指向一个指向整型数据的指针变量(二级指针)
void *p;            // p是一个指针变量,基类型为void,不指向具体的对象
```

---
## 🤔 Q&A

### Q1: 指针和地址有什么区别?
**A**: 地址是内存中的一个位置值,而指针是存储地址的变量。地址是概念,指针是实现。

### Q2: 什么是野指针?
**A**: 野指针是指向未知内存区域的指针,通常由以下情况产生:
- 指针未初始化
- 指针指向的内存已被释放但指针未置NULL
使用野指针会导致程序崩溃或不可预知的行为。

### Q3: 为什么free后要将指针置为NULL?
**A**: `free(p)`释放了内存,但`p`仍然保存着那个地址(成为野指针)。将`p`置为`NULL`可以避免意外使用已释放的内存。

### Q4: 指针数组和数组指针有什么实际应用?
**A**:
- **指针数组**: 常用于存储多个字符串,如命令行参数`char *argv[]`
- **数组指针**: 常用于处理二维数组,在函数间传递二维数组

## 🚀 Tasks
- [ ] 编写程序演示指针的基本用法
- [ ] 实现使用函数指针的计算器程序
- [ ] 练习使用malloc动态分配内存
- [ ] 分析并修复一个内存泄漏的程序
- [ ] 理解并区分指针数组和数组指针

## 📚 Reference
* C Primer Plus - 指针章节
* C语言程序设计(谭浩强)
* Expert C Programming

## 🕸️ Relation
* 这篇笔记是[[00_C_MOC|C语言知识体系]]的核心部分
* [[C语言基础 - 数组]]与指针密切相关
* [[C语言基础 - 函数]]中会涉及函数指针
* [[C语言进阶 - 字符串]]需要理解字符指针
* [[C语言进阶 - 结构体]]中会使用结构体指针
