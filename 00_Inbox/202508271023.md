---
create date: 2025-08-27  10:23
modify date: 2025-08-27  14:57:00
---

**Relative to:** #bflash_test #projDragon #c语言

# title: bflash_test代码学习随记
## typedef unsigned int U32;
简单地说这句话给 `unsigned int` 这个数据类型起了一个新名字 `U32`

其中
- `typedef` 是一个关键字，作用为类型定义，就是为已有的数据类型创建一个新的、自定义的名称（别名）。
- `unsigned int` 首先表示一个整数，用**unsigned**表示无符号的，所以合在一起只表示从0开始的正数，范围大约是0 到 +42亿（如果不定义成无符号的类型，范围大约是-21亿 到 +21亿）。

## 测试用例组

```C
typedef int (*BFT_CASE_CHECK_F)(U32);
typedef WW_RTN (*BFT_IMG_MODIFY_F)(void);
typedef U32 WW_RTN;

typedef struct
{
    char systemBinName[128];
    BFT_IMG_MODIFY_F modifyFun;
    BFT_CASE_CHECK_F checkFun;
} BFT_CASE_T;

static BFT_CASE_T s_bftCase[] = { 
    [0]={.systemBinName="bft_system.bin", .modifyFun=NULL, .checkFun=bft_case_check_sub_1}, 
    [1]={"bft_system.bin", bft_case_wrong_bi0_binfo_magic, bft_case_check_binfo_0_err}，
    ......
};
```
这组代码主要是定义了测试组的基本内容，包括用什么bin，是哪种错误情况，用哪种检验函数对其进行检验

### 函数指针类型定义
1. **`typedef int (*BFT_CASE_CHECK_F)(U32);`**
   
    - `typedef`: 我们正在定义一个类型别名。
    - `int ... (U32)`: 这描述了一个函数的“签名”或“原型”。这个函数接受一个 `U32` 类型的参数，并返回一个 `int` 类型的值。
    - `(*BFT_CASE_CHECK_F)`: 这表示我们定义的是一个**指针**，这个指针的名字叫做 `BFT_CASE_CHECK_F`。
    - **整合理解**: 我们定义了一个新的类型 `BFT_CASE_CHECK_F`。任何这个类型的变量，都是一个**指向函数的指针**，这个函数必须满足**接受一个U32参数，返回一个int**的条件。
    - **命名推断**: `BFT_CASE_CHECK_F` -> BFT Case Check Function。这显然是用来定义“测试用例检查函数”的。
2. **`typedef WW_RTN (*BFT_IMG_MODIFY_F)(void);`**
   
    - 同理，我们定义了一个新的类型 `BFT_IMG_MODIFY_F`。
    - 它是一个指向函数的指针。
    - 这个函数必须满足**不接受任何参数 (`void`)，返回一个 `WW_RTN` (也就是 `U32`) 类型的值**的条件。
    - **命名推断**: `BFT_IMG_MODIFY_F` -> BFT Image Modify Function。这显然是用来定义“镜像修改函数”的。

---

### 第二部分：结构体定义

现在我们有了上面这些“零件”，就可以用它们来组装一个更复杂的数据结构。
```C
typedef struct
{
    char systemBinName[128];
    BFT_IMG_MODIFY_F modifyFun;
    BFT_CASE_CHECK_F checkFun;
} BFT_CASE_T;
```


- **`typedef struct { ... } BFT_CASE_T;`**: 这定义了一个结构体，并给它起了一个别名 `BFT_CASE_T`。
- 这个结构体 `BFT_CASE_T` 包含了三个成员变量，用来描述一个完整的“测试用例” (Case)。
    1. **`char systemBinName[128];`**: 一个长度为128的字符数组，用来存储一个字符串，很明显是测试要用的二进制文件名。
    2. **`BFT_IMG_MODIFY_F modifyFun;`**: 一个 `BFT_IMG_MODIFY_F` 类型的变量。根据上面的定义，`modifyFun` 是一个**函数指针**。它将指向一个“修改函数”。
    3. **`BFT_CASE_CHECK_F checkFun;`**: 一个 `BFT_CASE_CHECK_F` 类型的变量。`checkFun` 也是一个**函数指针**，它将指向一个“检查函数”。

**小结**: `BFT_CASE_T` 是一个数据模板，用于描述一个测试流程：针对哪个**文件** (`systemBinName`)，先执行哪个**修改操作** (`modifyFun`)，再执行哪个**检查操作** (`checkFun`)。



- **`static BFT_CASE_T s_bftCase[]`**:
  
    - `static`: 这个数组 `s_bftCase` 只在当前文件中可见。`s_` 前缀通常是 `static` 变量的命名约定。
    - `BFT_CASE_T`: 数组中每个元素的类型都是我们上面定义的 `BFT_CASE_T` 结构体。
    - `s_bftCase[]`: 声明一个名为 `s_bftCase` 的数组。因为 `[]` 中没写大小，编译器会自动根据初始化列表中的元素数量来确定其大小（这里是2）。
	* 里面的内容是对数组进行初始化。里面有x个元素，代表x个测试用例。
#### 第一个测试用例 (索引为 0)

`[0]={.systemBinName="bft_system.bin", .modifyFun=NULL, .checkFun=bft_case_check_sub_1}`

- `[0]=`: 这是C99标准引入的**指定初始化**语法，明确表示这是在初始化数组的第0个元素。
- `{...}`: 内部是对一个 `BFT_CASE_T` 结构体的初始化。
- `.member=value`: 这也是指定初始化语法，明确地给结构体的某个成员赋值，好处是不用关心成员声明的顺序，而且代码更易读。
    - `.systemBinName="bft_system.bin"`: 文件名是 "bft_system.bin"。
    - `.modifyFun=NULL`: 修改函数的指针是 `NULL` (空指针)，意味着这个测试用例**没有修改步骤**。
    - `.checkFun=bft_case_check_sub_1`: 检查函数的指针指向了名为 `bft_case_check_sub_1` 的函数。这个函数必须在代码的其他地方定义好，并且其函数签名必须符合 `BFT_CASE_CHECK_F` 的要求（即 `int func(U32)`)。

#### 第二个测试用例 (索引为 1)

`[1]={"bft_system.bin", bft_case_wrong_bi0_binfo_magic, bft_case_check_binfo_0_err}`

- `[1]=`: 初始化数组的第1个元素。
- `{...}`: 这里使用了传统的**顺序初始化**，值会按顺序赋给结构体的成员。
    - `"bft_system.bin"` -> 赋给 `systemBinName`。
    - `bft_case_wrong_bi0_binfo_magic` -> 赋给 `modifyFun`。这必须是一个符合 `BFT_IMG_MODIFY_F` 类型的函数。
    - `bft_case_check_binfo_0_err` -> 赋给 `checkFun`。这必须是一个符合 `BFT_CASE_CHECK_F` 类型的函数。

### 总结

**这几行代码的核心思想是：**

**定义了一个配置表（一个数组），这个表里记录了多个测试方案。程序可以通过遍历这个 `s_bftCase` 数组，来自动执行一系列的测试。**

例如，程序可以这样执行第一个测试：

1. 读取 `s_bftCase[0]`。
2. 看到 `modifyFun` 是 `NULL`，跳过修改步骤。
3. 调用 `s_bftCase[0].checkFun` 指向的函数 (`bft_case_check_sub_1`) 来进行检查。

执行第二个测试：

1. 读取 `s_bftCase[1]`。
2. 调用 `s_bftCase[1].modifyFun` 指向的函数 (`bft_case_wrong_bi0_binfo_magic`) 对文件进行修改。
3. 调用 `s_bftCase[1].checkFun` 指向的函数 (`bft_case_check_binfo_0_err`) 来检查修改后的结果。

这种“数据驱动”的设计模式非常强大和灵活，因为如果你想增加、删除或修改一个测试用例，只需要修改这个数组的初始化列表，而不需要改动核心的测试执行逻辑代码。



## bft_case

for循环会遍历`s_bftCase`数组里的每一项测试用例



### ww_memset

`memset` 本来的作用是将一块指定大小的内存区域，用一个固定的字节值进行快速的填充，告诉它从哪里开始填，填什么数，填多大的空间

**函数原型**

```c
void *memset(void *s, int c, size_t n);
```

- `void *s`: **目标内存地址**。指向要被填充的内存块的指针。`void *` 表示它可以接受任何类型的指针。
- `int c`: **要填充的值**。虽然它的类型是 `int`，但函数在填充时会将其转换为 `unsigned char`（一个字节）。所以只有 `c` 的低8位有效。
- `size_t n`: **要填充的字节数**。`size_t` 是一个无符号整数类型。



**实际使用**

```c
ww_memset(buf: (void *)s_pBfTestBootStus, c: 0xff, n: sizeof(BFLASH_STUS_T));
```



- `s_pBfTestBootStus` 是一个指向“启动闪存测试状态”的静态指针
- `BFLASH_STUS_T *`: 指针指向的数据类型是一个名为 `BFLASH_STUS_T` 的结构体。这个结构体里应该定义了各种用于记录启动闪存测试状态的成员变量。
- `volatile`: **这是最重要的关键字！** `volatile` 告诉编译器，这个指针指向的内存地址的内容，随时可能被程序本身之外的东西改变（比如硬件、中断、DMA等）。因此，编译器不能对这块内存的读写操作进行任何优化（比如缓存到寄存器），每次访问都必须老老实实地去内存地址读取或写入。**强烈暗示 `s_pBfTestBootStus` 指向的是一块硬件寄存器或者与硬件直接交互的特殊内存区域 (SRAM)。**
- `buf: (void *)s_pBfTestBootStus`: 将 `s_pBfTestBootStus` 指针作为目标内存地址。这意味着，在执行这行代码之前，`s_pBfTestBootStus` **必须已经**被赋值了一个有效的地址

- `c: 0xff`: 要填充的字节值是 `0xFF`。在二进制里，`0xFF` 就是 `11111111`。也就是说，目标内存的**每一个比特位**都会被设置为 `1`。
- `n: sizeof(BFLASH_STUS_T)`: 要填充的内存大小，正好是 `BFLASH_STUS_T` 这个结构体的大小。

**核心作用**：将用于记录“启动闪存测试状态”的一整块内存区域，全部重置（或初始化）为 `0xFF`。



## bft_shm_load_file

这个函数里面游泳回到 `FILE`，这是一个典型的**“不透明类型”（Opaque Type）**

`FILE` 类型本质上是一个**结构体（`struct`）**。

- 它**不是文件本身**。
- 它包含了操作系统和C标准库为了**管理这个文件**所需要的所有信息。

里面可能有的信息（**注意：这些是内部实现，你不需要也无法直接访问它们**）

- **文件描述符**：操作系统给这个打开的文件的唯一编号。
- **文件缓冲区**：一块内存，用于暂存读写的数据，以提高效率（避免每次读写一个字节都去操作硬盘）。
- **当前读写位置**：一个指针，记录着文件下次要从哪里开始读或写。
- **文件状态标志**：记录文件是只读、只写还是读写，是否出错，是否已经读到文件末尾等。
- **文件名**等等...



使用时只需要直接调用标准函数 `fopen`, `fread`, `fclose`，这些函数会根据不同的操作系统，操作它们内部的、我们看不见的 `FILE` 结构体。

**动态管理：**当你调用 `fopen()` 函数时，它会在内存的**堆区**动态地分配一个 `FILE` 结构体，并把所有需要的信息填好，然后**返回这个结构体的地址（即指针）**给你。

具体参考：https://www.runoob.com/cprogramming/c-file-io.html